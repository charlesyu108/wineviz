<!DOCTYPE html>
<html>
  <head>
    <script src="https://d3js.org/d3.v4.min.js"></script>
  </head>
  <body>
    <h1> INFO 4310 HW 3 </h3>
  </body>
</html>

<style>

.links line {
  stroke: #999;
  stroke-opacity: 0.6;
}

.nodes circle {
  stroke: #fff;
  stroke-width: 1.5px;
}
</style>

<svg id = "varieties_svg" width = "960" height = "600" style = "border: 1px solid black"> </svg>
<svg id = "filtered_svg" width = "960" height = "600" style = "border: 1px solid black"> </svg> <!-- Jon's SVG -->

<script>

  // Loading Data In
  d3.queue()
    .defer(d3.csv, "data/filtered_wines.csv", function(d){
      d.points = Number(d.points);
      d.price = Number(d.price);
      return d;
    })
    .defer(d3.json, "data/wine_variety_similarities.json")
    .await(visualize);

  // Callback once data has been loaded in
  function visualize(error, wines, wine_sims){
    if (error) { console.log(error); }

    // DATA VARIABLES
    var sim_matrix = wine_sims["sim_matrix"];
    var variety_data =  wine_sims["varieties"];
    var variety_order = variety_data.map(function(d) { return d.name; });
    var variety_to_index = wine_sims["variety_to_index"];

    console.log("Data loaded!")

    // Make Variety Viz
    makeVarietyViz(variety_data, variety_to_index);

    // Make Plot Viz

    makeWineViz(wines, "Melon");

  }
  // Creating the Variety visualization
  function makeVarietyViz(variety_data, variety_to_index){

    // Building Graph Data Structures
    var wine_nodes = variety_data.map(function (d){ return {"name": d.name, "group": d.cluster}; })
    var edges = []
    variety_data.forEach(function (d){
      d.related.forEach( function (r){
        if (d.name > r.name) { edges.push({"source": d.name, "target": r.name, "value": r.score}); }
      });
    });

    // TODO: DEFINE COLORS
    var default_colors = ["#DAF7A6", "#900C3F", "#FFC300"]
    var highlightedNodeColor = "orange";
    var inactiveNodeColor = "gray";
    var color = function (d) {
       if (d > 1){ return default_colors[2]; }
       else { return default_colors[d]; }
     }
    // Begin Building
    var svg = d3.select("#varieties_svg"),
        width = svg.attr("width"),
        height = svg.attr("height")
        radius = 10;

    var simulation = d3.forceSimulation()
        .force("link", d3.forceLink().id(function (d){ return d.name; }))
        .force("charge", d3.forceManyBody().strength(-5)) // Repel strength
        .force("center", d3.forceCenter(width/2, height/2))
        .force("collision", d3.forceCollide().radius(radius));

    var link = svg.append("g")
        .attr("class", "links")
        .selectAll("line")
        .data(edges)
        .enter().append("line")
            .attr("stroke-width", 2);

    var node = svg.selectAll(".nodes")
      .data(wine_nodes)
      .enter()
      .append("g")
      .attr("class", "nodes")
      .call(d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended))
            .on("mouseover", mouseover)
            .on("mouseout", mouseout);

      node.append("circle")
          .attr("r", radius)
          .attr("default_color", function(d) {return color(d.group); })
          .style("fill", function (d) {return d3.select(this).attr("default_color")});

      node.append("title")
        .text(function (d){ return d.name});

      node.append("text")
        .attr("dy", -3)
        .attr("visibility", "hidden")
        .text(function (d){ return d.name});

      simulation
        .nodes(wine_nodes)
        .on("tick", ticked);

      simulation.force("link")
        .links(edges)

      function ticked() {
        link
          .attr("x1", function(d) {return d.source.x; })
          .attr("y1", function(d) {return d.source.y; })
          .attr("x2", function(d) {return d.target.x; })
          .attr("y2", function(d) {return d.target.y; });

        node
         .attr("transform", function (d) {
           var dx = Math.max(radius, Math.min(width - radius, d.x));
           var dy = Math.max(radius, Math.min(height - radius, d.y));
           return "translate(" + dx + ", " + dy + ")";});
      }

    function dragstarted(d) {
      if (!d3.event.active) simulation.alphaTarget(0.3).restart();
      d.fx = d.x;
      d.fy = d.y;
    }

    function dragged(d) {
      d.fx = d3.event.x;
      d.fy = d3.event.y;
    }

    function dragended(d) {
      if (!d3.event.active) simulation.alphaTarget(0);
      d.fx = null;
      d.fy = null;
    }

    function mouseover(d) {

      d3.select(this).select("circle")
        .transition()
          .duration(75)
          .attr("r", radius * 1.5);

      d3.select(this).select("text")
        .transition()
          .duration(75)
          .attr("visibility", "visible");

      var idx = variety_to_index[d.name];
      var rel_wines = variety_data[idx].related.map(function (d){ return d.name;});
      node.selectAll("circle")
        .style("fill", function(w){
          if (d.name == w.name) { return highlightedNodeColor }
          else if (rel_wines.indexOf(w.name) == -1) { return inactiveNodeColor }
          else { return highlightedNodeColor }
         });
    }

    function mouseout(d) {

      d3.select(this).select("circle")
        .transition()
          .duration(75)
          .attr("r", radius);


      d3.select(this).select("text")
        .transition()
          .duration(75)
          .attr("visibility", "hidden");


      node.selectAll("circle")
        .style("fill", function(w){ return d3.select(this).attr("default_color"); });
    }


  }

  function makeWineViz(wines, variety){

    // Begin Building
    var svg = d3.select("#filtered_svg"),
        width = svg.attr("width"),
        height = svg.attr("height"),
        padding = 40,
        radius = 10;

    var wineLabel = svg.append("text")
    .attr("x", 50)
    .attr("y", 50);



    // // setup x 
    // var xValue = function(d) { return d.Calories;}, // data -> value
    //   xScale = d3.scaleLinear().range([0, width]), // value -> display
    //   xMap = function(d) { return xScale(xValue(d));}, // data -> display
    //   xAxis = d3.svg.axis().scale(xScale).orient("bottom");

    // // setup y
    //   var yValue = function(d) { return d["Protein (g)"];}, // data -> value
    //   yScale = d3.scaleLinear().range([height, 0]), // value -> display
    //   yMap = function(d) { return yScale(yValue(d));}, // data -> display
    //   yAxis = d3.svg.axis().scale(yScale).orient("left");







    console.log(wines[0]);
    var filtered = wines.filter(function (d){ return d.variety == variety}); //its like a for loop applying the function to each object in wines


    //var filtered_price = filtered.filter(function (d){ return d.price > 30});
    //var filtered_rating = filtered.filter(function (d){ return d.variety == variety});
    console.log(filtered);




    // Setup scales
    var xScale = d3.scaleLinear().domain(d3.extent(filtered, function(d) {return d.price;}))
      .range([padding, width-padding]);

    var yScale = d3.scaleLinear().domain(d3.extent(filtered, function(d) {return d.points;}))
      .range([height - padding, padding]);



    // Setup Axes
    var xAxis = d3.axisBottom(xScale);
    svg.append('g').attr('transform', 'translate(0,' + (height - padding) + ')').call(xAxis);
     
    var yAxis = d3.axisLeft(yScale);
    svg.append('g').attr('transform', 'translate(' + padding + ', 0)').call(yAxis);


    var node = svg.append("g")
        .attr("class", "nodes")
        .selectAll("circle")
        .data(filtered)
        .enter().append("circle")
            .attr("r", radius)
            .attr("fill", 000000) //Double check on this
            // .call(d3.drag()
            //       .on("start", dragstarted)
            //       .on("drag", dragged)
            //       .on("end", dragended))
            //       .on("mouseover", mouseover)
            //       .on("mouseout", mouseout);


    // draw dots
    // svg.selectAll(".dot")
    //     .data(filtered)
    //   .enter().append("circle")
    //     .attr("class", "dot")
    //     .attr("r", 3.5)
    //     .attr("cx", xScale(function (d) {return d.price;}))
    //     .attr("cy", yScale(function (d) {return d.points;}))
    //     .style("fill", 000000)
        // .style("fill", function(d) { return color(cValue(d));}) 

        // .on("mouseover", function(d) {
        //     tooltip.transition()
        //          .duration(200)
        //          .style("opacity", .9);
        //     tooltip.html(d["Cereal Name"] + "<br/> (" + xValue(d) 
        //     + ", " + yValue(d) + ")")
        //          .style("left", (d3.event.pageX + 5) + "px")
        //          .style("top", (d3.event.pageY - 28) + "px");
        // })

        // .on("mouseout", function(d) {
        //     tooltip.transition()
        //          .duration(500)
        //          .style("opacity", 0);
        // });




  }

</script>
